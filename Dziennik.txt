//TODO
- Optymalizacja wysyłania danych oświetletlenia
- Przeniesienie obliczeń normalnych modelu z shadera do cpu.
- Tekstury
- Cubemap i Skybox
- cieniowanie?
- Ładowanie modeli

- Rozpoczęcie prac nad generacją kształtów morfujących (wczesne drzewa)

//DONE
- Klasa engine i zarządzanie silnikiem
- Renderer
- GameObject i zarządzanie komponentami
- rysowanie i komponent kamery (Renderable, Camera, Transform)
- UBO do mPV
- Oświetlenie i materiały jako UBO

14.04.2017
Zrobiony kontekst, podstawowa architektura. InputManager wtopiony w GLWindow, including loop. 
Co następne?
1. rysowanie i komponent kamera (Renderable, Camera)

20.03.2017
Wtop inputManagera w GLWindow, niech zwraca tylko InputState.
Ciekawy pomysł: dodawanie komponentu inputlistener który reagowałby na klawisze.

15.03.2017
Problem:
jak ładnie zdefiniować obiekt stanu wejścia ze statycznymi metodami akcji na tym obiekcie?
inputmanager -> inputlistener

03.05.2017
Tyły w pisaniu dziennika (POPRAWIĆ!). Projekt zaczyna wyglądać. Utworzona abstrakcja renderingu (wymagana optymalizacja view projection matrix),
utworzona schludna struktura obiektu gry i komponentów, trochę refaktoru. PIERWSZY KWADRAT
Uwaga:
OpenGL rysuje regułą prawej ręki! Front zawsze leci kolejnością przeciwną do wsk. zegara! Koordynaty ekranu zaczynają się od górnego lewego (0,0) w dół!

10.05.2017
Jak zrobić update UBO macierzy widoku i perspektywy.. Każda scena ma własną macierz widoku, perspektywy pewnie też.
Trzeba zrobić init UBO na samym początku, najlepiej wołać bezpośrednio z funkcji. Wtedy też od razu wołam ustawienie macierzy projekcji.
Później w każdej klatce ustawiam nową macierz widoku.

Każdy shader będzie to miał obowiązkowo, można więc taką rezerwacje pamięci zrobić w shaderze.

Scena chyba sama powinna się inicjalizować..

UBO będzie statyczny - dzielony między wszystkie shadery - więc shader powinien sam wiedzieć o tym ubo i go ustawiać i pilnować!

11.05.2017
Fix do input managera (behaviour nie może usuwać eventów!), fix do komunikacji między shaderem i obiektem, dodanie UBO jako statycznego dla wszystkich rejestrowanych shaderów.
Przygotowanie obiektu emitującego światło wraz z shaderami do modyfikacji.

Praca nad oświetleniem:
na razie oświetlenie statyczne, paskudnie zakodowane ale DZIAŁA!
Notatki na przyszłość:
Do oświetlenia diffuse ważne są wektory normalne do danego fragmentu aby prawidłowo je pozyskać należy obciąć translację z macierzy modelu (normalne nie posiadają pozycji, jedynie obrót i skalowanie).
Załatwia nam to obcięcie kolumny i wiersza 'w' z macierzy modelu. Ze skalowaniem też jest problem, nierównomierne skalowanie zakrzywia płaszczyznę do wekt. normalnego. Załatwia to transpose(inverse(model)).

UWAGA!!!!
Po implementacji modułu oświetlenia konieczna optymalizacja obliczania macierzy normalnych! mat3(transpose(inverse((model)) to bardzo droga operacja! Lepiej obliczyć to za wczasu raz na procku niż dla każdego wierzchołka!
Więcej info tutaj: https://learnopengl.com/#!Lighting/Basic-Lighting


13.05.2017
Ciężka szkoła nauki komunikacji CPU-GPU. Nauka po 2 dniach kombinowania z UBO? 
1. Narzędzia nvidii nie wspierają vs2017, 
2. Do przesyłania danych używać tylko skalarów (ułożonych po 4 lub z paddingiem) oraz wektorów lub macierzy 2 lub 4 elementowych. 
Inaczej CPU czyta swoje a GPU swoje, wszystko dzięki innym zasadom lokowania danych. std140 po stronie GPU wymusza dzielenie danych na bloki po 4N danych.
W końcu udało się stworzyć moduł oświetlenia z dynamiczną ilością lamp. Na razie jest oświetlenie punktowe i kierunkowe, na tym chyba na tę chwilę poprzestanę. Ew. można kiedyś rozbudować to o spotlight.
TODO:
po co za każdym razem wysyłać cały bufor? Wystarczy update bierzących lamp i indeksów, nie wpadną mi śmieciowe dane.

14.05